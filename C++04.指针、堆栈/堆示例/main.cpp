//
//  main.cpp
//  堆示例
//
//  Created by Fengur on 2017/8/1.
//  Copyright © 2017年 Fengur. All rights reserved.
//

#include <iostream>
using namespace std;

int main(int argc, const char * argv[]) {
    // 堆，是以链表形式存储的 所有的变量都是匿名存储的
    // 堆的上限是以系统最大虚拟内存决定的 很大也很灵活 需要程序员分配 一般速速比较慢 容易出现内存碎片
    // 堆是不连续的内存区域 各块区域由链表将他们串联起来 这些串联起来的内存空间叫做堆
    // 采用匿名的内存访问方式，只有使用特定的指针才能访问特定的数据 这样就避免了任何视图修改变量的非法操作
    // 堆中的变量是没有标签的
    
    
    // 在C++中 如果要在堆中开辟内存空间 需要使用new关键字
    // 在堆中，申请了4个字节的内存空间 由指针P保存
    int *p = new int;
    *p = 20;
    cout << "*p " << *p << ", p " << p <<endl;
    // 如果堆中的变量不再使用 在c++中一定要使用关键字delete 释放指针指向的地址
    // 如果不释放p 指针指向的堆空间 永远不会被释放 在xcode中用内存分析工具就可以分析出来
    
    delete p;
    // 安全释放 ，输了使用delete 释放指向的空间，还需要将指针地址指向 0
    // p = NULL; //(打开或者注释掉本句注释 可以看出明显效果)
    
    // 新分配的空间 需要程序员注意赋值
    int *p1 = new int;
    // 刚分配的空间中 有可能存在人任意的数值 而不是0
    *p1 = 50;
    
    // delete p 只是告诉系统 原有指向的空间不需要了 可以回收 系统并不一定立马回收 新分配的可能瞬间替换之前的值
    cout << "*p " << *p << ", p " << p <<endl;
    cout << "*p1 " << *p << ", p1 " << p1 <<endl;
    *p = 2000;
    
    cout << "*p " << *p << ", p " << p <<endl;
    // 过度释放，在MRC 中 同意不能过度释放
    // delete p;
    return 0;
}
